<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>GRAPHITE SKETCH</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <style>
    :root {
      --bg: #0b0e13;
      --fg: #e7eaee;
      --accent: #f5bf42; /* bell + frame accent */
      --muted: #8892a0;
      --danger: #ff4d4f;
      --ok: #36d399;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; background: var(--bg); color: var(--fg); font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif; }
    button { font: inherit; }
    .app {
      position: relative;
      height: 100dvh;
      width: 100vw;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--bg);
    }
    .video-wrap {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      background: #000;
    }
    video {
      max-width: 100%;
      max-height: 100%;
      width: 100vw;
      height: 100dvh;
      object-fit: contain; /* critical for accurate mapping */
      background: #000;
    }

    /* UI header row */
    .top-ui {
      position: absolute;
      top: 8px; /* lifted up as requested */
      left: 0;
      right: 0;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 8px 12px;
      pointer-events: none;
    }
    .status {
      pointer-events: auto;
      background: rgba(0,0,0,0.5);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 10px;
      padding: 6px 10px;
      font-size: 12px;
      line-height: 1.2;
      color: var(--fg);
      max-width: 70%;
    }
    .status strong { color: var(--accent); }

    /* Bell icon button (fixed UI) */
    .bell-btn {
      pointer-events: auto;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 44px;
      height: 44px;
      border-radius: 999px;
      border: 2px solid var(--accent);
      color: var(--accent);
      background: rgba(0,0,0,0.35);
      transition: transform 0.15s ease, background 0.15s ease;
      cursor: pointer;
    }
    .bell-btn:hover { transform: translateY(-1px) scale(1.02); background: rgba(245,191,66,0.15); }
    .bell-btn:active { transform: translateY(0) scale(0.98); }
    .bell-btn[disabled] { opacity: 0.5; cursor: not-allowed; }

    /* Center overlay hints and frame */
    .center-ui {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      pointer-events: none;
      padding: env(safe-area-inset-top) 16px env(safe-area-inset-bottom);
    }

    .frame-wrap {
      position: relative;
      width: min(80vw, 80vh); /* square guidance frame */
      aspect-ratio: 1 / 1;
      border: 3px dashed var(--accent);
      border-radius: 12px;
      background: rgba(245, 191, 66, 0.05);
      display: grid;
      place-items: center;
    }
    .hint {
      position: absolute;
      bottom: -36px;
      left: 0; right: 0;
      text-align: center;
      font-size: 13px;
      color: var(--muted);
    }

    /* Overlay container that will be aligned to the frame region (no clipping) */
    .overlay {
      position: absolute;
      /* size/position set dynamically to match the frame region */
      pointer-events: none;
      transform-origin: center center;
      /* no clipping so GIF doesn’t get cut by container box */
      overflow: visible;
      display: none; /* hidden until playing */
    }
    .overlay img {
      display: block;
      width: 100%;
      height: 100%;
      object-fit: contain; /* fill entire image area without cutting */
      image-rendering: auto;
      will-change: transform;
    }

    /* Start button and End screen */
    .start-wrap, .end-wrap {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      background: linear-gradient(180deg, rgba(11,14,19,0.9), rgba(11,14,19,0.6));
      backdrop-filter: blur(4px);
      padding: 24px;
      text-align: center;
    }
    .start-card, .end-card {
      background: rgba(0,0,0,0.55);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 14px;
      padding: 16px 18px;
      max-width: 560px;
    }
    .start-card h1, .end-card h2 { margin: 0 0 8px; font-weight: 700; font-size: 18px; }
    .start-card p, .end-card p { margin: 0 0 14px; font-size: 14px; color: var(--muted); }
    .primary {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 10px 14px;
      border-radius: 10px;
      border: 1px solid var(--accent);
      color: #0b0e13;
      background: var(--accent);
      cursor: pointer;
      transition: transform 0.15s ease, filter 0.15s ease;
      font-weight: 600;
    }
    .primary:hover { filter: brightness(1.05); transform: translateY(-1px); }
    .primary:active { transform: translateY(0); }

    .pill {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.08);
      color: var(--fg);
      font-size: 12px;
    }

    .small {
      font-size: 12px;
      color: var(--muted);
    }

    /* Visual confidence indicator */
    .confidence {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 12px;
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(0,0,0,0.35);
      color: var(--fg);
    }
    .dot {
      width: 8px; height: 8px; border-radius: 999px; background: var(--danger);
    }
    .dot.ok { background: var(--ok); }
  </style>
</head>
<body>
  <div class="app" id="app">
    <div class="video-wrap" id="videoWrap">
      <video id="video" playsinline autoplay muted></video>
    </div>

     Top UI: status + bell 
    <div class="top-ui">
      <div class="status" id="status">
        <div><strong>Step 1</strong> — Align your image inside the golden frame</div>
        <div><strong>Step 2</strong> — Tap the bell to lock and start</div>
        <div id="latlng" class="small">Lat: -, Long: -</div>
      </div>
      <button class="bell-btn" id="bellBtn" title="Lock and Start" disabled>
         Bell icon (SVG) 
        <svg width="22" height="22" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">
          <path d="M12 2a6 6 0 0 0-6 6v2.278c0 .49-.195.961-.542 1.308L4.3 12.744A2 2 0 0 0 5.707 16h12.586A2 2 0 0 0 19.7 12.744l-1.158-1.158a1.85 1.85 0 0 1-.542-1.308V8a6 6 0 0 0-6-6Zm0 20a3 3 0 0 0 3-3H9a3 3 0 0 0 3 3Z"/>
        </svg>
      </button>
    </div>

     Center frame hint 
    <div class="center-ui" id="centerUi">
      <div class="frame-wrap" id="guideFrame">
        <div class="hint">
          Place the image fully inside this frame, then tap the bell
        </div>
      </div>
    </div>

     Overlay container that matches frame position/size 
    <div class="overlay" id="overlay">
      <img id="overlayImg" alt="AR overlay" />
    </div>

     Start overlay 
    <div class="start-wrap" id="startWrap">
      <div class="start-card">
        <h1>Start Camera</h1>
        <p class="small" style="margin-bottom: 10px;"></p>
        <button class="primary" id="startBtn">Enable Camera</button>
      </div>
    </div>

     End overlay 
    <div class="end-wrap" id="endWrap" style="display:none;">
      <div class="end-card">
        <h2>Session Ended</h2>
        <p>Thanks! You can refresh the page to start again.</p>
        <div class="pill" id="summary">Locked at Lat -, Long -</div>
      </div>
    </div>

     Hidden canvases for processing 
    <canvas id="proc" width="320" height="240" style="display:none;"></canvas>
    <canvas id="roi" width="40" height="40" style="display:none;"></canvas>

     Audio element (primed on bell click) 
    <audio id="music" preload="auto" src="song.mp3" crossorigin="anonymous"></audio>
  </div>

  <script>
    const video = document.getElementById('video');
    const videoWrap = document.getElementById('videoWrap');
    const startWrap = document.getElementById('startWrap');
    const startBtn = document.getElementById('startBtn');
    const endWrap = document.getElementById('endWrap');
    const summary = document.getElementById('summary');

    const guideFrame = document.getElementById('guideFrame');
    const centerUi = document.getElementById('centerUi');
    const bellBtn = document.getElementById('bellBtn');

    const statusBox = document.getElementById('status');
    const latlngBox = document.getElementById('latlng');

    const overlay = document.getElementById('overlay');
    const overlayImg = document.getElementById('overlayImg');

    const proc = document.getElementById('proc');
    const ctx = proc.getContext('2d', { willReadFrequently: true });
    const roi = document.getElementById('roi');
    const rctx = roi.getContext('2d', { willReadFrequently: true });

    const music = document.getElementById('music');

    let stream = null;
    let rafId = null;

    // Lock data
    let locked = false;
    let lockTemplate = null; // Float32Array of downsampled grayscale (40x40)
    let lockRectVideo = null; // Rect in video pixel coords {x, y, w, h}
    let lockCenterNorm = { x: null, y: null }; // "latitude" and "longitude" (normalized 0..1)

    // Gating based on similarity
    let gateOk = false;
    const SIM_THRESHOLD = 0.18; // lower is more similar, tuned experimentally

    // Sequence (GIFs then Music)
    const sequence = [
      { src: 'gif1.gif', durationMs: 4000 },
      { src: 'gif2.gif', durationMs: 4000 },
      { src: 'gif2.gif', durationMs: 4000 }
    ];
    let seqIndex = 0;
    let seqRemaining = sequence.length ? sequence[0].durationMs : 0;
    let lastTick = 0;

    // Global End Timer (15s after lock)
    let endTimer = null;
    const SESSION_MS = 15000;

    function fmt(n) { return (Math.round(n * 1000) / 1000).toFixed(3); }

    function getContainerRects() {
      const appRect = document.getElementById('app').getBoundingClientRect();
      const videoRect = video.getBoundingClientRect();
      const frameRect = guideFrame.getBoundingClientRect();
      return { appRect, videoRect, frameRect };
    }

    function mapFrameToVideo() {
      // Map the displayed frame rectangle into video pixel coordinates
      const videoW = video.videoWidth || 640;
      const videoH = video.videoHeight || 480;
      const { appRect, videoRect, frameRect } = getContainerRects();

      const scale = Math.min(appRect.width / videoW, appRect.height / videoH);
      const displayedW = videoW * scale;
      const displayedH = videoH * scale;
      const offsetX = (appRect.width - displayedW) / 2 + appRect.left;
      const offsetY = (appRect.height - displayedH) / 2 + appRect.top;

      // Frame edges in display coords -> to video coords
      const fx0 = frameRect.left - offsetX;
      const fy0 = frameRect.top - offsetY;
      const fx1 = frameRect.right - offsetX;
      const fy1 = frameRect.bottom - offsetY;

      // Protect from negative due to letterboxing
      const vx0 = Math.max(0, fx0 / scale);
      const vy0 = Math.max(0, fy0 / scale);
      const vx1 = Math.min(videoW, fx1 / scale);
      const vy1 = Math.min(videoH, fy1 / scale);

      return {
        x: vx0,
        y: vy0,
        w: Math.max(1, vx1 - vx0),
        h: Math.max(1, vy1 - vy0),
        videoW, videoH
      };
    }

    function toGrayDownsample(srcCtxRect) {
      // Draw from video to processing canvas at small size, then extract ROI scaled to roi canvas (40x40)
      const { x, y, w, h } = srcCtxRect;
      // Draw current video frame into processing canvas at native video size
      const vw = video.videoWidth || 640;
      const vh = video.videoHeight || 480;
      proc.width = vw;
      proc.height = vh;
      ctx.drawImage(video, 0, 0, vw, vh);

      // Extract ROI region and downsample to 40x40
      const targetW = roi.width;
      const targetH = roi.height;
      rctx.clearRect(0, 0, targetW, targetH);
      rctx.drawImage(proc, x, y, w, h, 0, 0, targetW, targetH);
      const data = rctx.getImageData(0, 0, targetW, targetH).data;
      const gray = new Float32Array(targetW * targetH);
      for (let i = 0, j = 0; i < data.length; i += 4, j++) {
        // luma
        const g = 0.299 * data[i] + 0.587 * data[i+1] + 0.114 * data[i+2];
        gray[j] = g / 255;
      }
      return gray;
    }

    function meanAbsDiff(a, b) {
      if (!a || !b || a.length !== b.length) return 1;
      let sum = 0;
      for (let i = 0; i < a.length; i++) {
        sum += Math.abs(a[i] - b[i]);
      }
      return sum / a.length; // normalized 0..1
    }

    function updateBellEnabled() {
      // Enable bell when the current frame inside the guide frame is sufficiently stable compared to a rolling baseline
      // For simplicity, enable bell whenever the frame has "enough detail" (variance) → here, we just ensure it’s not blank
      const rect = mapFrameToVideo();
      const gray = toGrayDownsample(rect);
      let mean = 0, varsum = 0;
      for (let i = 0; i < gray.length; i++) mean += gray[i];
      mean /= gray.length;
      for (let i = 0; i < gray.length; i++) { const d = gray[i] - mean; varsum += d * d; }
      const variance = varsum / gray.length;
      // Simple heuristic: variance above threshold means there’s real content
      const ok = variance > 0.005; // experimentally reasonable
      bellBtn.disabled = !ok;
      setConfIndicator(ok);
    }

    function setConfIndicator(ok) {
      let el = document.getElementById('confInd');
      if (!el) {
        el = document.createElement('div');
        el.className = 'confidence';
        el.id = 'confInd';
        el.innerHTML = '<span class="dot"></span><span id="confText">Aligning...</span>';
        statusBox.appendChild(el);
      }
      const dot = el.querySelector('.dot');
      const txt = el.querySelector('#confText');
      if (ok) { dot.classList.add('ok'); txt.textContent = 'Ready: tap the bell'; }
      else    { dot.classList.remove('ok'); txt.textContent = 'Aligning...'; }
    }

    async function startCamera() {
      try {
        stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: { ideal: 'environment' } },
          audio: false
        });
        video.srcObject = stream;
        await video.play();
        startWrap.style.display = 'none';
        centerUi.style.display = 'grid';
        statusBox.style.display = 'block';
        bellBtn.style.display = 'inline-flex';
        loopAlign();
      } catch (err) {
        alert('Camera access failed. Please allow camera permission.');
        console.error(err);
      }
    }

    function loopAlign() {
      // While not locked, keep enabling/disabling the bell based on content in the frame region
      if (locked) return;
      updateBellEnabled();
      rafId = requestAnimationFrame(loopAlign);
    }

    function lockAndStart() {
      if (locked) return;
      // Record lock template and center "lat/long"
      const rect = mapFrameToVideo();
      lockRectVideo = rect;
      lockTemplate = toGrayDownsample(rect);
      lockCenterNorm = {
        x: (rect.x + rect.w / 2) / rect.videoW,
        y: (rect.y + rect.h / 2) / rect.videoH
      };
      latlngBox.textContent = `Lat: ${fmt(lockCenterNorm.x)} , Long: ${fmt(lockCenterNorm.y)}`;

      // Size and place overlay to match frame rect on screen
      positionOverlayToFrame();

      // Prime audio in user gesture context so it can play later
      try { music.play().then(() => { music.pause(); music.currentTime = 0; }).catch(()=>{}); } catch(e){}

      locked = true;
      // Update UI
      statusBox.innerHTML = `<div><strong>Locked</strong> — Hold steady to play</div><div class="small">Lat: ${fmt(lockCenterNorm.x)} , Long: ${fmt(lockCenterNorm.y)}</div>`;
      centerUi.style.display = 'none'; // Hide the big frame lines once locked (overlay remains sized the same)
      bellBtn.disabled = true;

      // Start global end timer (absolute 15 seconds)
      endTimer = setTimeout(endSession, SESSION_MS);

      // Start sequence flow, controlled by gating
      seqIndex = 0;
      seqRemaining = sequence.length ? sequence[0].durationMs : 0;
      lastTick = performance.now();
      overlay.style.display = 'block';
      overlayImg.src = (sequence[0] && sequence[0].src) || '';
      sequenceLoop();
      gateLoop();
    }

    function positionOverlayToFrame() {
      // Match overlay box to guideFrame’s display rect
      const frameRect = guideFrame.getBoundingClientRect();
      const appRect = document.getElementById('app').getBoundingClientRect();
      // Set overlay size and position exactly on top of frame
      overlay.style.left = `${frameRect.left - appRect.left}px`;
      overlay.style.top = `${frameRect.top - appRect.top}px`;
      overlay.style.width = `${frameRect.width}px`;
      overlay.style.height = `${frameRect.height}px`;
    }

    function gateLoop() {
      if (!locked) return;
      const current = toGrayDownsample(lockRectVideo);
      const diff = meanAbsDiff(current, lockTemplate);
      const ok = diff <= SIM_THRESHOLD;
      gateOk = ok;

      // Show/hide overlay and pause/resume music depending on gate
      if (ok) {
        overlay.style.visibility = 'visible';
        // music will start later after GIFs; if already started, ensure it's playing
        if (musicStarted) {
          music.play().catch(()=>{});
        }
      } else {
        overlay.style.visibility = 'hidden';
        if (musicStarted) {
          try { music.pause(); } catch(e){}
        }
      }

      // Keep adjusting overlay position in case viewport layout changes
      positionOverlayToFrame();

      requestAnimationFrame(gateLoop);
    }

    let musicStarted = false;

    function sequenceLoop(now) {
      if (!locked) return;
      if (typeof now !== 'number') now = performance.now();
      const dt = now - lastTick;
      lastTick = now;

      // Only count down when gate is OK
      if (gateOk && sequence.length > 0 && seqIndex < sequence.length) {
        seqRemaining -= dt;
        if (seqRemaining <= 0) {
          // Advance to next GIF
          seqIndex++;
          if (seqIndex < sequence.length) {
            overlayImg.src = sequence[seqIndex].src;
            seqRemaining = sequence[seqIndex].durationMs;
          } else {
            // All GIFs done: start music (plays only when gate OK)
            if (!musicStarted) {
              musicStarted = true;
              // Attempt to play; if gate is OK it should play; else will be paused until gateOk again
              music.play().catch(()=>{});
            }
          }
        }
      }

      // If no GIFs defined, start music immediately after lock when gate is OK
      if (sequence.length === 0 && gateOk && !musicStarted) {
        musicStarted = true;
        music.play().catch(()=>{});
      }

      requestAnimationFrame(sequenceLoop);
    }

    function stopStream() {
      if (stream) {
        for (const t of stream.getTracks()) t.stop();
      }
      video.srcObject = null;
    }

    function endSession() {
      locked = false;
      if (rafId) cancelAnimationFrame(rafId);
      try { music.pause(); } catch(e){}
      stopStream();
      overlay.style.display = 'none';
      bellBtn.disabled = true;

      const lat = lockCenterNorm.x != null ? fmt(lockCenterNorm.x) : '-';
      const lng = lockCenterNorm.y != null ? fmt(lockCenterNorm.y) : '-';
      summary.textContent = `Locked at Lat ${lat} , Long ${lng}`;
      endWrap.style.display = 'grid';
    }

    // Wire up events
    startBtn.addEventListener('click', startCamera);
    bellBtn.addEventListener('click', lockAndStart);

    // Handle resize/orientation to keep overlay aligned
    window.addEventListener('resize', () => {
      if (locked) positionOverlayToFrame();
    });
    window.addEventListener('orientationchange', () => {
      setTimeout(() => { if (locked) positionOverlayToFrame(); }, 250);
    });

    // Prevent scroll bounce on mobile
    document.addEventListener('touchmove', (e) => {
      if (!e.target.closest('.start-wrap') && !e.target.closest('.end-wrap')) {
        e.preventDefault();
      }
    }, { passive: false });

    // Fail-safe if media not found
    overlayImg.addEventListener('error', () => {
      // If GIF missing, just keep element blank without crashing
      overlayImg.style.background = 'rgba(0,0,0,0.25)';
    });
    music.addEventListener('error', () => {
      // Fail silently if music is missing
    });
  </script>
</body>
</html>
