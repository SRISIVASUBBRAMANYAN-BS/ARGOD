<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
    <title>GRAPHITE SKETCH AR</title>
    <style>
      :root{
        --brand:#0ea5e9;         /* primary */
        --accent:#f59e0b;        /* accent */
        --bg:#0b0b10;            /* neutral 1 */
        --fg:#e5e7eb;            /* neutral 2 */
        --muted:#9ca3af;         /* neutral 3 */
      }
      html,body{height:100%;background:var(--bg);color:var(--fg);margin:0;font-family:system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";}
      .app{position:fixed;inset:0;overflow:hidden;}
      video#camera{
        position:absolute; inset:0; width:100%; height:100%; object-fit:cover;
        background:#000;
        transform:none !important; -webkit-transform:none !important; /* ensure non-mirrored camera */
      }
      /* UI */
      .hud{
        position:absolute; inset:0; pointer-events:none; display:flex; flex-direction:column; justify-content:space-between;
        padding:16px;
        background: radial-gradient(1200px 600px at 50% -10%, rgba(14,165,233,0.15), transparent 60%);
      }
      header{
        pointer-events:none; text-align:center; margin-top:8px;
      }
      .title{
        display:inline-block; font-weight:800; letter-spacing:0.04em; text-transform:uppercase;
        font-size: clamp(18px, 4.5vw, 28px); padding:8px 14px; border-radius:999px;
        background:rgba(14,165,233,0.18); border:1px solid rgba(14,165,233,0.35); color:#e6f6ff; text-shadow:0 1px 0 rgba(0,0,0,.4);
        box-shadow:0 0 24px rgba(14,165,233,.25) inset, 0 8px 30px rgba(14,165,233,0.1);
      }
      .status{
        pointer-events:none; text-align:center; color:var(--muted); font-size:14px; margin:8px 0 0;
        text-shadow:0 1px 2px rgba(0,0,0,.5);
      }
      .controls{
        position:absolute; left:50%; bottom:20px; transform:translateX(-50%); display:flex; gap:12px; pointer-events:auto;
      }
      .btn{
        appearance:none; border:none; cursor:pointer;
        background:linear-gradient(180deg, rgba(14,165,233,0.85), rgba(14,165,233,0.55));
        color:#001219; font-weight:700; letter-spacing:.02em;
        padding:14px 18px; border-radius:12px; box-shadow: 0 10px 30px rgba(14,165,233,.35);
      }
      .btn:active{ transform:translateY(1px); }
      .btn.bell{ display:none; align-items:center; gap:8px; }
      .btn.bell svg{ width:18px; height:18px; }

      /* Guide frame while scanning */
      .guide{
        position:absolute; left:50%; top:50%; width:min(70vw, 360px); aspect-ratio:0.75; transform:translate(-50%,-50%);
        border:2px dashed rgba(229,231,235,.25); border-radius:12px;
      }

      /* AR overlay container anchored to match box */
      .ar-layer{
        position:absolute; left:0; top:0; pointer-events:none;
        will-change: transform, width, height, opacity; opacity:0; transition:opacity .35s ease;
      }
      .ar-layer.active{ opacity:1; }
      .ar-layer img.gif{
        position:absolute; inset:0; width:100%; height:100%;
        object-fit:cover; display:none; border-radius:10px; background:rgba(0,0,0,.2);
      }

      /* End screen */
      .end{
        position:absolute; inset:0; display:none; place-items:center; background:rgba(0,0,0,.6); backdrop-filter: blur(6px);
      }
      .end.show{ display:grid; }
      .end .panel{
        background:linear-gradient(180deg, rgba(2,6,23,0.8), rgba(2,6,23,0.6));
        border:1px solid rgba(229,231,235,.14);
        box-shadow:0 30px 80px rgba(0,0,0,.5), inset 0 0 60px rgba(14,165,233,.08);
        color:var(--fg); padding:22px 24px; border-radius:16px; text-align:center; max-width:90vw;
      }
      .end h2{ margin:0 0 8px; font-size:20px; letter-spacing:.02em; }
      .end p{ margin:0 0 16px; color:var(--muted); font-size:14px; }
      .end .btn{ background:linear-gradient(180deg, rgba(245,158,11,0.9), rgba(245,158,11,0.6)); }

      /* Hidden working canvases */
      canvas#work, canvas#tmpl{ display:none; }

      /* Small sparkle when target locks */
      .spark{
        position:absolute; width:8px; height:8px; border-radius:999px; background:#fff;
        box-shadow:0 0 12px #fff, 0 0 30px var(--brand), 0 0 60px var(--accent);
        animation: pop .8s ease forwards;
      }
      @keyframes pop{
        0%{ transform:scale(.2); opacity:0; }
        40%{ transform:scale(1.6); opacity:1; }
        100%{ transform:scale(1); opacity:.0; }
      }
    </style>
  </head>
  <body>
    <div class="app" id="app">
       Camera 
      <video id="camera" muted playsinline autoplay></video>

       Hidden target reference image (for detection).
           Replace src with your exact target reference if different. 
      <img id="refImg" alt="Target reference" crossOrigin="anonymous"
           src="graphite-target.png"
           style="position:absolute; left:-9999px; top:-9999px; width:320px; height:auto;" />

       UI HUD 
      <div class="hud">
        <header>
          <div class="title">Welcome to GRAPHITE SKETCH</div>
          <div class="status" id="status">Tap Start to allow back camera. Keep the target fully inside the frame.</div>
        </header>
        <div class="guide" id="guide"></div>
        <div class="controls">
          <button class="btn" id="startBtn" style="display:inline-block;">Start AR</button>
          <button class="btn" id="stopBtn" style="display:none;">Stop</button>
          <button class="btn bell" id="bellBtn" aria-label="Ring bell to start" style="display:none;">
            <svg viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">
              <path d="M12 2a1 1 0 0 1 1 1v.28a7 7 0 0 1 5 6.72v3.3l1.38 2.77A1 1 0 0 1 18.5 18h-13a1 1 0 0 1-.88-1.43L6 13.3V10a7 7 0 0 1 5-6.72V3a1 1 0 0 1 1-1Zm0 20a3 3 0 0 1-3-3h6a3 3 0 0 1-3 3Z"/>
            </svg>
            Bell
          </button>
        </div>
      </div>

       AR Overlay (anchored where the image is detected)
           Replace the 3 GIFs below with your own files under ./assets/ 
      <div class="ar-layer" id="arLayer" aria-hidden="true">
        <img id="gif1" class="gif" src="1.gif" alt="" />
        <img id="gif2" class="gif" src="2.gif" alt="" />
        <img id="gif3" class="gif" src="3.gif" alt="" />
      </div>

       End Screen 
      <div class="end" id="end">
        <div class="panel">
          <h2>AR session ended</h2>
          <p>Thanks for exploring GRAPHITE SKETCH.</p>
          <button class="btn" id="restartBtn">Restart</button>
        </div>
      </div>

       Working canvases 
      <canvas id="work" width="320" height="240"></canvas>
      <canvas id="tmpl" width="120" height="160"></canvas>

       Background audio: replace with your MP3 under ./assets/music.mp3 
      <audio id="bgm" preload="auto">
        <source src="song.mp3" type="audio/mpeg" />
      </audio>
    </div>

    <script>
      // ---- Utility: Speech greeting (optional) ----
      function sayWelcome(){
        try{
          const u = new SpeechSynthesisUtterance("Welcome to Graphite Sketch");
          u.rate = 0.95; u.pitch = 1; u.lang = "en-US";
          speechSynthesis.cancel();
          speechSynthesis.speak(u);
        }catch(e){}
      }

      // ---- Elements ----
      const video = document.getElementById('camera');
      const startBtn = document.getElementById('startBtn');
      const stopBtn = document.getElementById('stopBtn');
      const statusEl = document.getElementById('status');
      const endScreen = document.getElementById('end');
      const restartBtn = document.getElementById('restartBtn');
      const arLayer = document.getElementById('arLayer');
      const guide = document.getElementById('guide');
      const bgm = document.getElementById('bgm');
      const bellBtn = document.getElementById('bellBtn');
      const gif1 = document.getElementById('gif1');
      const gif2 = document.getElementById('gif2');
      const gif3 = document.getElementById('gif3');
      const refImg = document.getElementById('refImg');

      // ---- State ----
      let stream = null;
      let rafId = null;
      let scanning = false;
      let locked = false;
      let consecutiveHits = 0;
      let playing = false;
      let paused = false;
      let missFrames = 0;
      let seqStartTs = 0;
      let elapsedMs = 0;
      let currentSeg = 0; // 0,1,2 for 3 GIFs
      const segDur = [5000, 5000, 5000]; // total 15000
      let tSeg1 = null, tSeg2 = null, tEnd = null;

      let geoWatchId = null;
      let currentLat = null, currentLng = null;
      let homeLat = null, homeLng = null; // saved on bell click
      const RADIUS_METERS = 30;

      // ---- Camera ----
      async function startCamera(){
        try{
          stream = await navigator.mediaDevices.getUserMedia({
            video: { facingMode: { ideal: "environment" }, width:{ideal:1280}, height:{ideal:720} },
            audio: false
          });
          video.srcObject = stream;
          await video.play();
        }catch(err){
          console.error(err);
          statusEl.textContent = "Camera permission denied or unavailable.";
        }
      }
      function stopCamera(){
        if(stream){
          stream.getTracks().forEach(t => t.stop());
          stream = null;
        }
      }

      // ---- Detection core: template preparation + NCC scanning ----
      const work = document.getElementById('work');
      const wctx = work.getContext('2d',{willReadFrequently:true});
      const tmpl = document.getElementById('tmpl');
      const tctx = tmpl.getContext('2d',{willReadFrequently:true});

      let tW = 120, tH = 160;  // template size (downscaled)
      let tVec = null, tMean = 0, tNorm = 1;

      function toGray(data){
        const out = new Float32Array((data.length/4)|0);
        for(let i=0,j=0;i<data.length;i+=4,j++){
          out[j] = (0.299*data[i] + 0.587*data[i+1] + 0.114*data[i+2])/255;
        }
        return out;
      }
      function meanAndNorm(vec){
        let sum=0; for(let i=0;i<vec.length;i++) sum+=vec[i];
        const mean = sum/vec.length;
        let sq=0; for(let i=0;i<vec.length;i++){ const d=vec[i]-mean; sq+=d*d; }
        const norm = Math.sqrt(sq);
        return [mean, norm || 1];
      }
      function dotNCC(a, aMean, aNorm, b, bMean, bNorm){
        let s=0;
        for(let i=0;i<a.length;i++){
          s += (a[i]-aMean)*(b[i]-bMean);
        }
        return s/(aNorm*bNorm);
      }

      async function prepareTemplate(){
        await new Promise(res=>{
          if(refImg.complete) res(); else refImg.onload = res;
        });
        const r = refImg.naturalHeight/refImg.naturalWidth;
        tH = Math.round(tW*r);
        tmpl.width = tW; tmpl.height = tH;
        tctx.drawImage(refImg, 0, 0, tW, tH);
        const tData = tctx.getImageData(0,0,tW,tH).data;
        tVec = toGray(tData);
        [tMean, tNorm] = meanAndNorm(tVec);
      }

      function findTarget(){
        const vw = video.videoWidth || 1280;
        const vh = video.videoHeight || 720;
        const scale = 360 / Math.min(vw, vh);
        const fw = Math.round(vw*scale);
        const fh = Math.round(vh*scale);

        work.width = fw; work.height = fh;
        wctx.drawImage(video, 0, 0, fw, fh);

        const frame = wctx.getImageData(0,0,fw,fh);
        const fGray = toGray(frame.data);
        const winW = tW, winH = tH;

        let best = {score:-1, x:0, y:0, w:winW, h:winH};
        const step = 8;
        for(let y=0;y<=fh-winH; y+=step){
          for(let x=0;x<=fw-winW; x+=step){
            const wVec = new Float32Array(winW*winH);
            let k=0;
            for(let yy=0;yy<winH;yy++){
              const rowStart = (y+yy)*fw + x;
              for(let xx=0;xx<winW;xx++){
                wVec[k++] = fGray[rowStart+xx];
              }
            }
            const [wMean, wNorm] = meanAndNorm(wVec);
            const s = dotNCC(wVec, wMean, wNorm, tVec, tMean, tNorm);
            if(s>best.score){ best={score:s, x, y, w:winW, h:winH}; }
          }
        }

        const screenW = video.clientWidth;
        const screenH = video.clientHeight;
        const rx = screenW/fw;
        const ry = screenH/fh;

        return {
          score: best.score,
          left: best.x*rx,
          top: best.y*ry,
          width: best.w*rx,
          height: best.h*ry
        };
      }

      function showSpark(x,y){
        const s=document.createElement('div');
        s.className='spark';
        s.style.left=(x-4)+'px';
        s.style.top=(y-4)+'px';
        s.style.position='absolute';
        document.body.appendChild(s);
        setTimeout(()=>s.remove(),800);
      }

      function primeAudio() {
        return bgm.play().then(() => {
          bgm.pause();
          bgm.currentTime = 0;
        }).catch(()=>{ /* ignore */ });
      }

      function showOnly(el){
        [gif1, gif2, gif3].forEach(g=>{ g.style.display='none'; });
        if(el) el.style.display='block';
      }

      function scheduleTimers(startOffsetMs){
        let acc = 0;
        currentSeg = 0;
        for (let i=0;i<segDur.length;i++){
          if(startOffsetMs < acc + segDur[i]) { currentSeg = i; break; }
          acc += segDur[i];
        }
        showOnly([gif1, gif2, gif3][currentSeg]);

        const remainingInSeg = acc + segDur[currentSeg] - startOffsetMs;
        [tSeg1, tSeg2, tEnd].forEach(id => { if(id) clearTimeout(id); });
        tSeg1 = tSeg2 = tEnd = null;

        if(currentSeg === 0){
          tSeg1 = setTimeout(()=>{ showOnly(gif2); currentSeg = 1; }, remainingInSeg);
          tSeg2 = setTimeout(()=>{ showOnly(gif3); currentSeg = 2; }, remainingInSeg + segDur[1]);
          tEnd  = setTimeout(()=>{ try{ bgm.pause(); }catch(e){} finishOverlay(); }, remainingInSeg + segDur[1] + segDur[2]);
        } else if(currentSeg === 1){
          tSeg2 = setTimeout(()=>{ showOnly(gif3); currentSeg = 2; }, remainingInSeg);
          tEnd  = setTimeout(()=>{ try{ bgm.pause(); }catch(e){} finishOverlay(); }, remainingInSeg + segDur[2]);
        } else {
          tEnd  = setTimeout(()=>{ try{ bgm.pause(); }catch(e){} finishOverlay(); }, remainingInSeg);
        }
      }

      async function startSequence(){
        if(playing) return;
        playing = true;
        paused = false;
        missFrames = 0;
        seqStartTs = performance.now();
        elapsedMs = 0;
        currentSeg = 0;

        const totalMs = Number.isFinite(bgm.duration) && bgm.duration>0 ? Math.round(bgm.duration*1000) : 15000;
        segDur[0] = Math.floor(totalMs/3);
        segDur[1] = Math.floor(totalMs/3);
        segDur[2] = totalMs - segDur[0] - segDur[1];

        showOnly(gif1);
        arLayer.classList.add('active');
        statusEl.textContent = "Playing 3-part sequence…";

        (async ()=>{
          try{
            bgm.currentTime = 0;
            await bgm.play();
          }catch(e){}
        })();
        bgm.onended = () => { finishOverlay(); };

        scheduleTimers(0);
      }

      function pauseSequence(){
        if(!playing || paused) return;
        paused = true;
        elapsedMs += performance.now() - seqStartTs;
        try { bgm.pause(); } catch(e){}
        [tSeg1, tSeg2, tEnd].forEach(id => { if(id) clearTimeout(id); });
        tSeg1 = tSeg2 = tEnd = null;
        arLayer.classList.remove('active');
        statusEl.textContent = "Target lost or out of location. Hold the image in frame to resume.";
      }

      async function resumeSequence(){
        if(!playing || !paused) return;
        paused = false;
        seqStartTs = performance.now();
        try { await bgm.play(); } catch(e){}
        scheduleTimers(elapsedMs);
        arLayer.classList.add('active');
        statusEl.textContent = "Resumed.";
      }

      function finishOverlay(){
        showOnly(null);
        arLayer.classList.remove('active');
        playing = false;
        paused = false;
        [tSeg1, tSeg2, tEnd].forEach(id => { if(id) clearTimeout(id); });
        tSeg1 = tSeg2 = tEnd = null;
        statusEl.textContent = "Sequence finished. Point at the image to play again.";
      }

      // ---- AR Flow ----
      async function startAR(){
        sayWelcome();
        startBtn.style.display='none';
        stopBtn.style.display='inline-block';
        statusEl.textContent = "Initializing back camera…";
        await Promise.all([startCamera(), prepareTemplate()]);
        await primeAudio();
        startGeoWatch();
        statusEl.textContent = "Keep the image fully inside the frame. When locked, tap the bell to save your location and start.";
        guide.style.borderColor = 'rgba(14,165,233,.45)';

        scanning = true;
        locked = false;
        consecutiveHits = 0;
        playing = false;
        paused = false;
        missFrames = 0;
        arLayer.classList.remove('active');
        bellBtn.style.display='none';
        scanLoop();
      }

      function stopAR(){
        scanning = false;
        cancelAnimationFrame(rafId);
        try{ bgm.pause(); }catch(e){}
        arLayer.classList.remove('active');
        stopBtn.style.display='none';
        endScreen.classList.add('show');
        statusEl.textContent = "Session ended.";
        bellBtn.style.display='none';
        stopGeoWatch();
        stopCamera();
      }

      function restart(){
        endScreen.classList.remove('show');
        startBtn.style.display='inline-block';
        statusEl.textContent = "Tap Start to allow back camera. Keep the target in the frame.";
      }

      function scanLoop(){
        if(!scanning) return;
        const match = findTarget();

        function insideGuide(rect){
          const g = guide.getBoundingClientRect();
          const leftOk = rect.left >= g.left + 4;
          const topOk = rect.top >= g.top + 4;
          const rightOk = (rect.left + rect.width) <= (g.right - 4);
          const bottomOk = (rect.top + rect.height) <= (g.bottom - 4);
          return leftOk && topOk && rightOk && bottomOk;
        }

        if(match.score > 0.86){
          consecutiveHits++;
          arLayer.style.transform = `translate(${match.left}px, ${match.top}px)`;
          arLayer.style.width = `${match.width}px`;
          arLayer.style.height = `${match.height}px`;

          const inFrame = insideGuide(match);

          if(!locked && consecutiveHits>=3 && inFrame){
            locked = true;
            showSpark(match.left+match.width/2, match.top+match.height/2);
            statusEl.textContent = "Target locked in frame. Tap the bell to save location and start.";
          }

          if(locked && inFrame && !playing && !paused){
            bellBtn.style.display='inline-flex';
          }else{
            bellBtn.style.display='none';
          }

          if(playing){
            missFrames = 0;
            const canPlayHere = (homeLat==null || withinRadius());
            if(!inFrame || !canPlayHere){
              if(!paused) pauseSequence();
            }else{
              if(paused) resumeSequence();
              arLayer.classList.add('active');
            }
          }
        } else {
          consecutiveHits = 0;
          bellBtn.style.display='none';
          if(playing && !paused){
            missFrames++;
            if(missFrames > 8){
              pauseSequence();
            }
          }else{
            arLayer.classList.remove('active');
          }
        }

        rafId = requestAnimationFrame(scanLoop);
      }

      startBtn.addEventListener('click', startAR);
      stopBtn.addEventListener('click', stopAR);
      restartBtn.addEventListener('click', restart);

      bellBtn.addEventListener('click', ()=>{
        if(!locked || playing) return;
        if(!navigator.geolocation){
          statusEl.textContent = "Geolocation not available; cannot save location.";
          return;
        }
        navigator.geolocation.getCurrentPosition(async (pos)=>{
          homeLat = pos.coords.latitude;
          homeLng = pos.coords.longitude;
          statusEl.textContent = "Location saved. Starting…";
          bellBtn.style.display='none';
          startSequence();
        }, ()=>{
          statusEl.textContent = "Location permission denied. Cannot start.";
        }, { enableHighAccuracy:true, timeout:5000 });
      });

      function haversineMeters(lat1, lon1, lat2, lon2){
        if([lat1,lon1,lat2,lon2].some(v=>v==null)) return Infinity;
        const toRad = d=>d*Math.PI/180;
        const R=6371000;
        const dLat = toRad(lat2-lat1), dLon = toRad(lon2-lon1);
        const a = Math.sin(dLat/2)**2 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)**2;
        return 2*R*Math.asin(Math.sqrt(a));
      }
      function withinRadius(){
        if(homeLat==null || homeLng==null || currentLat==null || currentLng==null) return false;
        return haversineMeters(currentLat,currentLng,homeLat,homeLng) <= RADIUS_METERS;
      }
      function startGeoWatch(){
        if(!navigator.geolocation) return;
        geoWatchId = navigator.geolocation.watchPosition(
          (pos)=>{
            currentLat = pos.coords.latitude;
            currentLng = pos.coords.longitude;
          },
          ()=>{ /* ignore errors */ },
          { enableHighAccuracy:true, maximumAge:2000, timeout:5000 }
        );
      }
      function stopGeoWatch(){
        if(geoWatchId!=null && navigator.geolocation){
          navigator.geolocation.clearWatch(geoWatchId);
          geoWatchId = null;
        }
      }

      document.addEventListener('DOMContentLoaded', () => {
        startBtn.style.display='inline-block';
        statusEl.textContent = "Tap Start to allow back camera. Keep the target fully inside the frame, then tap the bell.";
      }, { once: true });

      // Hide GIFs if missing files to avoid errors
      [gif1, gif2, gif3].forEach(img=>{
        img.addEventListener('error', ()=>{ img.style.display='none'; }, {passive:true});
      })
    </script>
  </body>
</html>
